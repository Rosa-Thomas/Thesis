"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.roundBuffer = exports.verifyBeacon = exports.verifySigOnG1 = void 0;
const bls12_381_1 = require("@noble/curves/bls12-381");
const sha256_1 = require("@noble/hashes/sha256");
const utils_1 = require("@noble/curves/abstract/utils");
const buffer_1 = require("buffer");
const index_1 = require("./index");
async function verifyBeacon(chainInfo, beacon, expectedRound) {
    const publicKey = chainInfo.public_key;
    if (beacon.round !== expectedRound) {
        console.error('round was not the expected round');
        return false;
    }
    if (!await randomnessIsValid(beacon)) {
        console.error('randomness did not match the signature');
        return false;
    }
    if ((0, index_1.isChainedBeacon)(beacon, chainInfo)) {
        return bls12_381_1.bls12_381.verify(beacon.signature, await chainedBeaconMessage(beacon), publicKey);
    }
    if ((0, index_1.isUnchainedBeacon)(beacon, chainInfo)) {
        return bls12_381_1.bls12_381.verify(beacon.signature, await unchainedBeaconMessage(beacon), publicKey);
    }
    if ((0, index_1.isG1G2SwappedBeacon)(beacon, chainInfo)) {
        return verifySigOnG1(beacon.signature, await unchainedBeaconMessage(beacon), publicKey);
    }
    if ((0, index_1.isG1Rfc9380)(beacon, chainInfo)) {
        return verifySigOnG1(beacon.signature, await unchainedBeaconMessage(beacon), publicKey, 'BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_');
    }
    console.error(`Beacon type ${chainInfo.schemeID} was not supported or the beacon was not of the purported type`);
    return false;
}
exports.verifyBeacon = verifyBeacon;
function normP1(point) {
    return point instanceof bls12_381_1.bls12_381.G1.ProjectivePoint ? point : bls12_381_1.bls12_381.G1.ProjectivePoint.fromHex(point);
}
function normP2(point) {
    return point instanceof bls12_381_1.bls12_381.G2.ProjectivePoint ? point : bls12_381_1.bls12_381.G2.ProjectivePoint.fromHex(point);
}
function normP1Hash(point, domainSeparationTag) {
    return point instanceof bls12_381_1.bls12_381.G1.ProjectivePoint ? point : bls12_381_1.bls12_381.G1.hashToCurve((0, utils_1.ensureBytes)('point', point), { DST: domainSeparationTag });
}
async function verifySigOnG1(signature, message, publicKey, 
// default DST is the invalid one used for 'bls-unchained-on-g1' for backwards compat
domainSeparationTag = 'BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_') {
    const P = normP2(publicKey);
    const Hm = normP1Hash(message, domainSeparationTag);
    const G = bls12_381_1.bls12_381.G2.ProjectivePoint.BASE;
    const S = normP1(signature);
    const ePHm = bls12_381_1.bls12_381.pairing(Hm, P.negate(), true);
    const eGS = bls12_381_1.bls12_381.pairing(S, G, true);
    const exp = bls12_381_1.bls12_381.fields.Fp12.mul(eGS, ePHm);
    return bls12_381_1.bls12_381.fields.Fp12.eql(exp, bls12_381_1.bls12_381.fields.Fp12.ONE);
}
exports.verifySigOnG1 = verifySigOnG1;
async function chainedBeaconMessage(beacon) {
    const message = buffer_1.Buffer.concat([
        signatureBuffer(beacon.previous_signature),
        roundBuffer(beacon.round)
    ]);
    return (0, sha256_1.sha256)(message);
}
async function unchainedBeaconMessage(beacon) {
    return (0, sha256_1.sha256)(roundBuffer(beacon.round));
}
function signatureBuffer(sig) {
    return buffer_1.Buffer.from(sig, 'hex');
}
function roundBuffer(round) {
    const buffer = buffer_1.Buffer.alloc(8);
    buffer.writeBigUInt64BE(BigInt(round));
    return buffer;
}
exports.roundBuffer = roundBuffer;
async function randomnessIsValid(beacon) {
    const expectedRandomness = (0, sha256_1.sha256)(buffer_1.Buffer.from(beacon.signature, 'hex'));
    return buffer_1.Buffer.from(beacon.randomness, 'hex').compare(expectedRandomness) == 0;
}
//# sourceMappingURL=beacon-verification.js.map