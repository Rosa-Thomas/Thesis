"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.retryOnError = exports.jsonOrError = exports.defaultHttpOptions = exports.roundTime = exports.roundAt = exports.sleep = void 0;
// this is generated by the `precompile` npm script
// using the package.json version itself messes with the generated javascript, so it must be known
// at compile time
const version_1 = require("./version");
function sleep(timeMs) {
    return new Promise(resolve => {
        if (timeMs <= 0) {
            resolve();
        }
        setTimeout(resolve, timeMs);
    });
}
exports.sleep = sleep;
function roundAt(time, chain) {
    if (!Number.isFinite(time)) {
        throw new Error('Cannot use Infinity or NaN as a beacon time');
    }
    if (time < chain.genesis_time * 1000) {
        throw Error('Cannot request a round before the genesis time');
    }
    return Math.floor((time - (chain.genesis_time * 1000)) / (chain.period * 1000)) + 1;
}
exports.roundAt = roundAt;
function roundTime(chain, round) {
    if (!Number.isFinite(round)) {
        throw new Error('Cannot use Infinity or NaN as a round number');
    }
    round = round < 0 ? 0 : round;
    return (chain.genesis_time + (round - 1) * chain.period) * 1000;
}
exports.roundTime = roundTime;
// taking a separate `userAgent` param for backwards compatibility
exports.defaultHttpOptions = {
    userAgent: `drand-client-${version_1.LIB_VERSION}`,
};
// eslint-disable-next-line  @typescript-eslint/no-explicit-any
async function jsonOrError(url, options = exports.defaultHttpOptions) {
    const headers = { ...options.headers };
    if (options.userAgent) {
        headers['User-Agent'] = options.userAgent;
    }
    const response = await fetch(url, { headers });
    if (!response.ok) {
        throw Error(`Error response fetching ${url} - got ${response.status}`);
    }
    return await response.json();
}
exports.jsonOrError = jsonOrError;
async function retryOnError(fn, times) {
    try {
        return await fn();
    }
    catch (err) {
        if (times === 0) {
            throw err;
        }
        return retryOnError(fn, times - 1);
    }
}
exports.retryOnError = retryOnError;
//# sourceMappingURL=util.js.map