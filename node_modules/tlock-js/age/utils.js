"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sliceUntil = exports.chunked = exports.unpaddedBase64Buffer = exports.unpaddedBase64 = void 0;
const buffer_1 = require("buffer");
// as per the spec:
// RFC 4648, Section 4
// without = padding characters (sometimes referred to as "raw" or "unpadded" base64)
function unpaddedBase64(buf) {
    const encodedBuf = buffer_1.Buffer.from(buf).toString("base64");
    let lastIndex = encodedBuf.length - 1;
    while (encodedBuf[lastIndex] === "=") {
        lastIndex--;
    }
    return encodedBuf.slice(0, lastIndex + 1);
}
exports.unpaddedBase64 = unpaddedBase64;
function unpaddedBase64Buffer(buf) {
    return buffer_1.Buffer.from(unpaddedBase64(buf), "base64");
}
exports.unpaddedBase64Buffer = unpaddedBase64Buffer;
/*
    e.g. chunked("hello world", 2, ".") returns
    ["he.", "ll.", "o .", "wo.", "rl.", "d."]
 */
function chunked(input, chunkSize, suffix = "") {
    const output = [];
    let currentChunk = "";
    for (let i = 0, chunks = 0; i < input.length; i++) {
        currentChunk += input[i];
        const posInChunk = i - (chunks * chunkSize);
        if (posInChunk === chunkSize - 1) {
            output.push(currentChunk + suffix);
            currentChunk = "";
            chunks++;
        }
        else if (i === input.length - 1) {
            output.push(currentChunk + suffix);
        }
    }
    return output;
}
exports.chunked = chunked;
// slices the input string up to and including the first
// occurrence of the string provided in `searchTerm`
// returns the whole string if it's not found
// e.g. sliceUntil("hello world", "ll") will return "hell"
function sliceUntil(input, searchTerm) {
    let lettersMatched = 0;
    let inputPointer = 0;
    while (inputPointer < input.length && lettersMatched < searchTerm.length) {
        if (input[inputPointer] === searchTerm[lettersMatched]) {
            ++lettersMatched;
        }
        else if (input[inputPointer] === searchTerm[0]) {
            lettersMatched = 1;
        }
        else {
            lettersMatched = 0;
        }
        ++inputPointer;
    }
    return input.slice(0, inputPointer);
}
exports.sliceUntil = sliceUntil;
//# sourceMappingURL=utils.js.map