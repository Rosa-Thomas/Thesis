"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.readAge = exports.header = exports.writeAge = void 0;
const buffer_1 = require("buffer");
const utils_1 = require("./utils");
const utils_crypto_1 = require("./utils-crypto");
// takes the model to be encrypted and encodes everything to a string
// inserting newlines, other tags and the hmac as per the spec
function writeAge(input) {
    const headerStr = header(input);
    const macKey = mac((0, utils_crypto_1.createMacKey)(input.fileKey, input.headerMacMessage, headerStr));
    const payload = buffer_1.Buffer.from(input.body).toString("binary");
    return `${headerStr} ${macKey}\n${payload}`;
}
exports.writeAge = writeAge;
// ends with a `---`, as this is included in the header when
// calculating the MAC
function header(input) {
    return `${input.version}\n${recipients(input.recipients)}---`;
}
exports.header = header;
const recipients = (stanzas) => stanzas.map(it => recipient(it) + "\n");
const recipient = (stanza) => {
    const type = stanza.type;
    const aggregatedArgs = stanza.args.join(" ");
    const encodedBody = (0, utils_1.unpaddedBase64)(stanza.body);
    const chunkedEncodedBody = (0, utils_1.chunked)(encodedBody, 64).join("\n");
    return `-> ${type} ${aggregatedArgs}\n` + chunkedEncodedBody;
};
// The `---` preceding the MAC is technically part of the MAC-able text
// so it's included in the header instead
const mac = (macStr) => (0, utils_1.unpaddedBase64)(macStr);
// parses an AGE encrypted string into a model object with all the
// relevant parts encoded correctly
// throws an error if things are missing, in the wrong place or cannot
// be parsed
function readAge(input) {
    const [version, ...lines] = input.split("\n");
    const recipients = parseRecipients(lines);
    const macStartingTag = "--- ";
    const macLine = lines.shift();
    if (!macLine || !macLine.startsWith(macStartingTag)) {
        throw Error("Expected mac, but there were no more lines left!");
    }
    const mac = buffer_1.Buffer.from(macLine.slice(macStartingTag.length, macLine.length), "base64");
    // any remaining newlines are actually part of the payload
    const ciphertext = buffer_1.Buffer.from(lines.join("\n") ?? "", "binary");
    return {
        header: { version, recipients, mac },
        body: ciphertext
    };
}
exports.readAge = readAge;
// validates the code points of the characters of the args in line with the go implementation
// see: https://github.com/FiloSottile/age/blob/8e3f74c283b2e9b3cd0ec661fa4008504e536d20/internal/format/format.go#L301
function validateArguments(args) {
    args.forEach(arg => {
        for (let i = 0; i < arg.length; i++) {
            const charCode = arg.charCodeAt(i);
            if (charCode < 33 || charCode > 126) {
                throw Error(`Invalid character ${arg[i]} in argument ${arg}`);
            }
        }
    });
}
// parses all the recipient stanzas from `lines`
// modifies `lines`!!
function parseRecipients(lines) {
    const recipients = [];
    for (let current = peek(lines); current != null && current.startsWith("->"); current = peek(lines)) {
        const [type, ...args] = current.slice(3, current.length).split(" ");
        lines.shift();
        validateArguments(args);
        const body = parseRecipientBody(lines);
        if (!body) {
            throw Error(`expected stanza '${type} to have a body, but it didn't`);
        }
        recipients.push({ type, args, body: buffer_1.Buffer.from(body, "base64") });
    }
    if (recipients.length === 0) {
        throw Error("Expected at least one stanza! (beginning with -->)");
    }
    return recipients;
}
function parseRecipientBody(lines) {
    let body = "";
    for (let next = peek(lines); next != null; next = peek(lines)) {
        body += lines.shift();
        if (next.length < 64) {
            break;
        }
    }
    return body;
}
function peek(arr) {
    return arr[0];
}
//# sourceMappingURL=age-reader-writer.js.map