"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decryptAge = exports.encryptAge = void 0;
const hkdf_1 = require("@noble/hashes/hkdf");
const sha256_1 = require("@noble/hashes/sha256");
const stream_cipher_1 = require("./stream-cipher");
const no_op_encdec_1 = require("./no-op-encdec");
const age_reader_writer_1 = require("./age-reader-writer");
const utils_1 = require("./utils");
const utils_crypto_1 = require("./utils-crypto");
const buffer_1 = require("buffer");
const ageVersion = "age-encryption.org/v1";
const headerMacMessage = "header"; // some plaintext used to generate the mac
const hkdfBodyMessage = "payload"; // some plaintext used for generating the key for encrypting the body
const fileKeyLengthBytes = 16;
const bodyHkdfNonceLengthBytes = 16;
const hkdfKeyLengthBytes = 32;
// encrypts a plaintext payload using AGE by generating a fileKey
// and passing the fileKey to another `EncryptionWrapper` for handling
async function encryptAge(plaintext, wrapFileKey = no_op_encdec_1.NoOpEncDec.wrap) {
    const fileKey = await (0, utils_crypto_1.random)(fileKeyLengthBytes);
    const recipients = await wrapFileKey(fileKey);
    const body = await encryptedPayload(fileKey, plaintext);
    return (0, age_reader_writer_1.writeAge)({
        fileKey,
        version: ageVersion,
        recipients,
        headerMacMessage,
        body
    });
}
exports.encryptAge = encryptAge;
async function encryptedPayload(fileKey, payload) {
    const nonce = await (0, utils_crypto_1.random)(bodyHkdfNonceLengthBytes);
    const hkdfKey = (0, hkdf_1.hkdf)(sha256_1.sha256, fileKey, nonce, buffer_1.Buffer.from(hkdfBodyMessage, "utf8"), hkdfKeyLengthBytes);
    const ciphertext = stream_cipher_1.STREAM.seal(payload, hkdfKey);
    return buffer_1.Buffer.concat([nonce, ciphertext]);
}
// decrypts a payload that has been encrypted using AGE can unwrap
// any internal encryption by passing a `DecryptionWrapper` that can
// provide the `fileKey` created during encryption
async function decryptAge(payload, unwrapFileKey = no_op_encdec_1.NoOpEncDec.unwrap) {
    const encryptedPayload = (0, age_reader_writer_1.readAge)(payload);
    const version = encryptedPayload.header.version;
    if (version !== ageVersion) {
        throw Error(`The payload version ${version} is not supported, only ${ageVersion}`);
    }
    const fileKey = await unwrapFileKey(encryptedPayload.header.recipients);
    const header = (0, utils_1.sliceUntil)(payload, "---");
    const expectedMac = (0, utils_1.unpaddedBase64Buffer)((0, utils_crypto_1.createMacKey)(fileKey, headerMacMessage, header));
    const actualMac = encryptedPayload.header.mac;
    if (buffer_1.Buffer.compare(actualMac, expectedMac) !== 0) {
        throw Error("The MAC did not validate for the fileKey and payload!");
    }
    const nonce = buffer_1.Buffer.from(encryptedPayload.body.slice(0, bodyHkdfNonceLengthBytes));
    const cipherText = encryptedPayload.body.slice(bodyHkdfNonceLengthBytes);
    const hkdfKey = (0, hkdf_1.hkdf)(sha256_1.sha256, fileKey, nonce, buffer_1.Buffer.from(hkdfBodyMessage, "utf8"), hkdfKeyLengthBytes);
    const plaintext = stream_cipher_1.STREAM.open(cipherText, hkdfKey);
    return buffer_1.Buffer.from(plaintext);
}
exports.decryptAge = decryptAge;
//# sourceMappingURL=age-encrypt-decrypt.js.map