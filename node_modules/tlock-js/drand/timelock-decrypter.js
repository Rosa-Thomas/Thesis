"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTimelockDecrypter = void 0;
const buffer_1 = require("buffer");
const drand_client_1 = require("drand-client");
const ibe = __importStar(require("../crypto/ibe"));
const bls12_381_1 = require("@noble/curves/bls12-381");
function createTimelockDecrypter(network) {
    return async (recipients) => {
        const tlockStanza = recipients.find(it => it.type === "tlock");
        if (!tlockStanza) {
            throw Error("You must pass a timelock stanza!");
        }
        const { type, args, body } = tlockStanza;
        if (type !== "tlock") {
            throw Error(`Timelock expects the type of the stanza to be "tlock`);
        }
        if (args.length !== 2) {
            throw Error(`Timelock stanza expected 2 args: roundNumber and chainHash. Only received ${args.length}`);
        }
        const chainInfo = await network.chain().info();
        // should probably verify chain hash here too
        const roundNumber = parseRoundNumber(args);
        if ((0, drand_client_1.roundTime)(chainInfo, roundNumber) > Date.now()) {
            throw Error(`It's too early to decrypt the ciphertext - decryptable at round ${roundNumber}`);
        }
        const beacon = await (0, drand_client_1.fetchBeacon)(network, roundNumber);
        console.log(`beacon received: ${JSON.stringify(beacon)}`);
        switch (chainInfo.schemeID) {
            case "pedersen-bls-unchained": {
                const ciphertext = parseCiphertext(body, bls12_381_1.bls12_381.G1.ProjectivePoint.BASE);
                return await ibe.decryptOnG1(buffer_1.Buffer.from(beacon.signature, "hex"), ciphertext);
            }
            case "bls-unchained-on-g1": {
                const ciphertext = parseCiphertext(body, bls12_381_1.bls12_381.G2.ProjectivePoint.BASE);
                return await ibe.decryptOnG2(buffer_1.Buffer.from(beacon.signature, "hex"), ciphertext);
            }
            case "bls-unchained-g1-rfc9380": {
                const ciphertext = parseCiphertext(body, bls12_381_1.bls12_381.G2.ProjectivePoint.BASE);
                return await ibe.decryptOnG2(buffer_1.Buffer.from(beacon.signature, "hex"), ciphertext);
            }
            default:
                throw Error(`Unsupported scheme: ${chainInfo.schemeID} - you must use a drand network with an unchained scheme for timelock decryption!`);
        }
    };
    function parseRoundNumber(args) {
        const [roundNumber] = args;
        const roundNumberParsed = Number.parseInt(roundNumber);
        // compare against itself, to make sure it's not NaN
        if (roundNumberParsed !== roundNumberParsed) {
            throw Error(`Expected the roundNumber arg to be a number, but it was ${roundNumber}!`);
        }
        return roundNumberParsed;
    }
    function parseCiphertext(body, base) {
        const pointLength = base.toRawBytes(true).byteLength;
        const pointBytes = body.subarray(0, pointLength);
        const theRest = body.subarray(pointLength);
        const eachHalf = theRest.length / 2;
        const U = pointBytes;
        const V = theRest.subarray(0, eachHalf);
        const W = theRest.subarray(eachHalf);
        return { U, V, W };
    }
}
exports.createTimelockDecrypter = createTimelockDecrypter;
//# sourceMappingURL=timelock-decrypter.js.map